import type { NextApiRequest, NextApiResponse } from 'next';
import { GameConfigService, GameSessionService } from '../../../src/lib/database';
import { v4 as uuidv4 } from 'uuid';

// SIMPLE SYSTEM: Only count discount codes by IP address
async function checkDiscountCodeLimit(shopDomain: string, ipAddress: string): Promise<{
  canPlay: boolean;
  reason?: string;
  codesUsed: number;
  maxCodes: number;
  nextResetTime?: string;
}> {
  console.log('ðŸŽ® Checking discount code limit for IP:', ipAddress);
  
  // Get configuration
  const gameConfig = await GameConfigService.getConfig(shopDomain);
  if (!gameConfig || !gameConfig.isEnabled) {
    return { canPlay: false, reason: 'shop_inactive', codesUsed: 0, maxCodes: 0 };
  }

  const maxCodes = gameConfig.gameSettings.maxPlaysPerCustomer || 3;
  const resetHours = gameConfig.gameSettings.playLimitResetHours || 24;
  
  console.log('ðŸŽ® Settings - maxCodes:', maxCodes, 'resetHours:', resetHours);

  // Get time cutoff (24 hours ago by default)
  const cutoffTime = new Date();
  cutoffTime.setHours(cutoffTime.getHours() - resetHours);
  
  console.log('ðŸŽ® Checking codes generated after:', cutoffTime.toISOString());

  // Count discount codes generated by this IP in the time period
  const codesUsed = await countDiscountCodesByIP(shopDomain, ipAddress, cutoffTime);
  
  console.log('ðŸŽ® Codes used:', codesUsed, '/ max:', maxCodes);

  if (codesUsed >= maxCodes) {
    console.log('ðŸŽ® Limit reached!');
    return {
      canPlay: false,
      reason: 'code_limit',
      codesUsed,
      maxCodes,
      nextResetTime: new Date(cutoffTime.getTime() + (resetHours * 60 * 60 * 1000)).toISOString()
    };
  }

  return {
    canPlay: true,
    codesUsed,
    maxCodes
  };
}

// Simple function to count discount codes by IP
async function countDiscountCodesByIP(shopDomain: string, ipAddress: string, afterTime: Date): Promise<number> {
  try {
    console.log('ðŸŽ® Counting discount codes for IP:', ipAddress);
    
    // Get all sessions for this shop
    const allSessions = await GameSessionService.getSessionsByShop(shopDomain, 1000);
    console.log('ðŸŽ® Total sessions found:', allSessions.length);
    
    // Filter by IP, time, and discount code existence
    const relevantSessions = allSessions.filter(session => {
      const hasIP = session.ipAddress === ipAddress;
      const hasTime = session.startedAt.toDate() > afterTime;
      const hasCode = session.discountCode && session.discountCode.trim() !== '';
      
      return hasIP && hasTime && hasCode;
    });
    
    console.log('ðŸŽ® Sessions with discount codes for this IP:', relevantSessions.length);
    console.log('ðŸŽ® Discount codes found:', relevantSessions.map(s => s.discountCode));
    
    return relevantSessions.length;
  } catch (error) {
    console.error('ðŸŽ® Error counting discount codes:', error);
    return 0; // Return 0 on error to allow playing
  }
}

function getClientIP(req: NextApiRequest): string {
  const forwarded = req.headers['x-forwarded-for'];
  const ip = forwarded ? (Array.isArray(forwarded) ? forwarded[0] : forwarded.split(',')[0]) : req.socket.remoteAddress;
  return ip || 'unknown';
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { shop, shopDomain } = req.body;
    const shopName = shop || shopDomain; // Accept both parameter names
    const ipAddress = getClientIP(req);

    console.log('ðŸŽ® Start session request for shop:', shopName, 'IP:', ipAddress);

    if (!shopName) {
      return res.status(400).json({ error: 'Shop parameter is required' });
    }

    // Check discount code limit
    const limitCheck = await checkDiscountCodeLimit(shopName, ipAddress);

    if (!limitCheck.canPlay) {
      console.log('ðŸŽ® Discount code limit reached, blocking session');
      return res.status(403).json({
        success: false,
        sessionId: '',
        gameConfig: null,
        canPlay: false,
        playsRemaining: 0,
        error: `Cannot play: ${limitCheck.reason}`,
        reason: limitCheck.reason,
        codesUsed: limitCheck.codesUsed,
        maxCodes: limitCheck.maxCodes,
        nextResetTime: limitCheck.nextResetTime
      });
    }

    // Get game configuration
    const gameConfig = await GameConfigService.getConfig(shopName);
    if (!gameConfig) {
      return res.status(404).json({ error: 'Game configuration not found' });
    }

    // Create new session
    const sessionId = uuidv4();
    console.log('ðŸŽ® Creating session:', sessionId);

    await GameSessionService.createSession({
      sessionId,
      shopDomain: shopName,
      ipAddress,
      userAgent: req.headers['user-agent'] || '',
      startedAt: new Date(),
      completed: false
    });

    console.log('ðŸŽ® Session created successfully');

    return res.status(200).json({
      success: true,
      sessionId,
      gameConfig: gameConfig.gameSettings,
      canPlay: true,
      playsRemaining: limitCheck.maxCodes - limitCheck.codesUsed,
      codesUsed: limitCheck.codesUsed,
      maxCodes: limitCheck.maxCodes
    });

  } catch (error) {
    console.error('ðŸŽ® Error in start-session:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
}
